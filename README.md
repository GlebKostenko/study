# Описание курса

## Содержание

[Инструкция](#Инструкция)  
[Задание 1](#Задание-1)  
[Задание 2](#Задание-2)  
[Задание 3](#Задание-3)  
[Задание 4](#Задание-4)

## Инструкция.

**Человек напишет какой-то код, постарайтесь обратить внимание на моменты, которые сделаны не оптимально,
например, человек считает кол-во элементов в коллекции с помощью цикла, а мог бы вызвать метод объекта, вместо
лямбда-функции, пишет то же самое но длиннее, не использует Stream Api, где это возможно,предложите более
лучшую структуру данных в конкретной ситуации, даже если придется поменять реализацию в нескольких местах, если вы
знаете какой-то не сильно сложный в понимании алгоритм, который облечит чтение кода и ,возможно, оптимизирует его,
предложите человеку поискать, что это за алгоритм и какой кусок кода следует заменить. Следите за тем чтобы всё
соответствовало этому
документу [Конвенции](https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html). Для
тестов нет определенных
соглашений, но лучше использовать следующую схему для нейминга "Класс теста называем в соответствии с именем класса
только добавляем Test в конце, методы следующим образом
ЧтоМетодДелает_whenСозданыОпределнныеУсловия_ThenShouldBeОжидаемыйРезультат". Человек может принимать
непривычные решения относительно реализации в коде, использовать например статические методы, где они не нужны,
внутренние классы, неграмотно пользоавться полями или примитивами, в таком случае либо объясните почему так не делают,
либо дайте ссылку для ознакомления(видео, статья, форум), либо напишите, что нужно изучить, чтобы разобраться. Если
видите, что есть хорошая возможность продемонстрировать работу какого-либо паттерна предложите его реализовать, но
дейлайте так, только в том случае, когда решение напрашивается само собой. Самое важное вы не пишите код за человека, не
додумываете решения пока человек не предоставит своё решение, оснавная суть, чтобы он мог гуглить и делал это на
английском, вы должны дать понимание о чем гуглить, исправлять неправильно интерптированную информацию.**

## Задание 1

Напишите консольное приложение, которое по тексту, введенному пользователем, будет искать слово, которое ввел
пользователь, в случае успеха надо вывести YES, в остальных случаях выведите NO.

С решением могут помочь следующие инструменты:

* StreamAPI
* Lambda-function
* Map
* ArrayList
* Class

## Задание 2

В дополнение к предыдущему заданию добавьте следующую логику, если слово существует, выведите YES, а так же для каждого
слова входящего в текст замените его на слово resolved и выведите этот текст. Протестируйте приложение с помощью JUnit.

С решением могут помочь следующие инструменты:

* Maven
* JUnit

### Примечание

Здесь предполагается использование StreamAPI, не говорите человеку, как он в идеале должен это сделать, возможно, кто-то
захочет сделать с использованием Stack, Array, ArrayList, когда он сделает скажите, что это неэффективно, так человек
проведет исследовательскую работу и будет лучше понимать, как пользоваться структурами и как они работают. Также после
написания попросите человека выделить реализацию в отдельный класс, если приложение написано в функции main.Если текст
или слово null выведите сообщение об этом.

## Задание 3

Боб работает на фабрике по производству опасных химикатов, по внутренним каналам организации распространился слух,
что формулы этих химикатов попали не в те руки, Боб хочет предотвратить возможную угрозу, для этого у него есть Алиса,
которая работает в ФБР, но данные нужно передать в зашифрованном виде, чтобы преступники не поняли, что их раскрыли.
Каждый день ФБР присылает секретную фразу, где английские буквы представляют собой символы, сегодня это фраза  
"The quick brown fox jumps over the lazy dog - TZ{9R71@&?=NYQ=4$R5XE=%{?TZ{/#F+A=!" зашифруйте фразу, котрую введет Боб
в консоль и протестируйте работу приложения.

С решением могут помочь следующие инструменты:

* List, ArrayList
* Map
* Классы с полями
* Override стандартных методов Object
* Interface

### Примечание

Тут не указано шифрование для пробелов, цифр и символов, человек должен подумать об этом и спросить у вас,
если он этого не сделал, то для начала предложите ему подумать все ли случаи он учел(в том числе, что проихойдет, если
предать пустую строку, null), если человек не догадывается, то
спросите, а все ли символы мы закодировали, подскажите, что могут быть и такие случаи, для этого предложите следующий
способ:  
Для каждого символа используйте следующий формат  "!"3{1, 7, 9}, где "!" - символ который не зашифровали, 3-сколько раз
он встречается в тексте, а в фигурных скобках позиции, где он встречается, порядок не имеет значения, можно реализовть
как отдельный класс с переопределением метода toString, а можно List<ArrayList>, можно Map, в выходном шифре
все кроме букв пропускатеся. Пример:

```
Console:
 Hello World! My name is Bob
 " "5{5, 12, 15, 20, 23}
 "!"1{11}
 Z{//=N=?/A5+Y#5{7E&=&
``` 

{ A-#,
B-&,
C-1,
D-A,
E-{,
F-Q,
G-!,
H-Z,
I-7,
J-$,
K-@,
L-/,
M-5,
N-Y,
O-=,
P-X,
Q-9,
R-?,
S-E,
T-T,
U-R,
V-%,
W-N,
X-4,
Y-+,
Z-F }.  
Так как шифровать можно не только текст, но и видео, аудио, то лучше всего сделать интерфейс с каим-то методом,
имплементировать его в конгкретной реализации для текста.Так же хорошей подготовкой к дальнейшим заданием будет
реализация прокси класса, где мы заведем поле имеющее тип интерфейса, а в конструкторе будем присваивать имплементацию
интерфейса, это позволит не зависеть от конкретной реализации, а также будет хорошей отсылкой на Dependency Injection в
Spring.

## Задание 5

В сборную России по футболу ищут нового перспективного нападающего, ставку делают на скорость игрока, но это не
единственный фактор, также значительную роль играют процент голов игрока из зоны штрафной и престижность клуба, в
котором он находится. Побеждает футболист с наибольшим количеством очков, они рассчитываются по следующей формуле

```
12000 - время бега в миллисекундах + 10*(процент голов) + 2*(престижность клуба) 
```

Составьте таблицу с игроками и запишите её в выходной файл.  
[Данные игроков](./footbalers.txt)

С решением могут помочь следующие инструменты:

* Three-Tier Architecture
* File procession

### Примечание

Здесь хорошо проследите за тем, чтобы была соблюдена трехслойная архитектура, должен быть отдельно пэкедж с файлами для
получения данных dao/data/repository, также можно сделать отдельный класс Footballer, он скорее должен находится в
пэкедже model, выисление данных и сортировка футболистов по местам это основная бизнес-логика программы, поэтому такой
класс должен расоплагаться в пэкедже service, здесь в качестве поля скорее всего нужно будет использовать класс из
repository, парсинг данных нужно проводить в классе из repository, так как service должен получать сразу данные, которые
ему нужны, а не выделять их из кучи ненужного. Обработка файлов должна производится с использованием StreamAPI,
Lambda-функций и цепочек методов, также в dao можно сделать интерфейс с методом getParameters(), допустим, если вы
рассматриваете футболистов на другие позиции, то вас могут интересовать другие параметры, а в сервисе можно использовать
тот же метод.
